{
    "collab_server" : "",
    "contents" : "start_time <- proc.time()\nsource(\"Code/Init.R\")\nset.seed(1)\n\n# Example script\n\n# ------------------------------------------\n# INPUT DATA AND SETTINGS\n\n# Model settings\n# --------------\n# Models - gridded datasets of data values as a vector\n# Model outputs are stored in directory Model_Data/<Model_set> with filenames <models>.txt\n# Directory should also contain a file mask.txt with the indices of the region to be analysed\n# IDL file um2krig will prepare UM data appropriately\nModel_set='CO2_anom'\nmodels = c('tdgth', 'tczyi', 'tdgtj', 'tczyj', 'tdgtg', 'tczyk', 'tdgtk', 'tdgti')\n\n# Specify grid dimensions for model data\n# (lon_min,lon_max,lon_int,lat_min,lat_max,lat_int)\nmodel_grid <- c(-180,178.75,1.25,-89.375,89.375,1.25) # HadCM3 ocean temps, shifted 1 hemisphere\n# model_grid <- c(-180,176.25,3.75,-90,90,2.5)          # HadCM3 atmosphere temps, shifted 1 hemisphere\n# model_grid <- c(-179.5,179.5,1.0,89.5,-89.5,-1.0)     # HadISST data\n\n# Observations\n# -------------\n# Observations need to have points in a list of 4 columns with headers \"x,y,z,std\" = lon, lat, observation, uncertainty\n# Observations are stored in directory Observation_Data/<Obs_set> with filenames <obs>.txt\nObs_set='P3+_SST_anom'\nobs = c('lambda_100', 'lambda_90', 'lambda_80', 'lambda_70', 'lambda_60', 'lambda_50', 'lambda_40', 'lambda_30', 'lambda_20', 'lambda_10')\n\n# Mesh settings\n# -------------\n# Choose egg or sphere mesh\n#manifold = \"Egg\" \n manifold = \"Sphere\"\n\n# Matlab is called for egg meshes to generate new mesh with specified anisotropy = \"stretch\"  (MATLAB file: Generate_Mesh_egg.m)\n# stretch = sqrt of equatorial radius, default 0.05 (polar radius = 1)\n# Although stretch=1 should give a sphere, this doesn't actually seem to work for a reason I haven't worked out, use sphere option.\n#stretch <- 0.05 # Egg\n\n# Sphere - writes different set of mesh files (MATLAB file: Generate_Mesh.m)\n# For sphere option, don't need to vary radius, use smooth to vary region of influence, so this mesh is not updated.\nstretch <- 1 # Sphere\n\n# Calculation settings\n# -------------------\n# smoothness parameter, i.e. radius of influence. So higher is smoother. Default is smooth = 0.3.\nsmooth = 0.3\n\n# These lines retained for reference only - context within greater system.\nfit = \"Obs\" # \"Sim\" \"Obs\" or \"Model\"\n\n# Output\n# -------------------\nmesh <- paste0(manifold,\"-\",stretch)\noutdir <- paste0(\"Output/O-\",Obs_set,\"_M-\",Model_set,\"_ME-\",mesh,\"_SM-\",smooth)\n\n# ------------------------------------------\n# END - INPUT DATA AND SETTINGS\n# ------------------------------------------\n\n# INITIALISATION\n\nr = c(sqrt(stretch), sqrt(stretch),1) \nmodel_grid_rad <- model_grid*pi/180.\nLmodel_summary <- matrix(data=NA,nrow=length(obs),ncol=length(models))\n\n# SET UP GLOBAL MESH\n\n#Adjust radius in 3d space accordingly\nif (manifold == \"Egg\") {\n# Call Matlab to generate egg mesh with specified stretch value\nif (.Platform$OS.type == \"windows\"){\n    Matlab$startServer()\n    matlab_server <<- Matlab(remote=F)\n    Sys.sleep(10)\n    open(matlab_server)\n  } else if (.Platform$OS.type == \"unix\"){\n    Matlab$startServer()\n    matlab_server <<- Matlab(remote=F)\n    Sys.sleep(10)\n    open(matlab_server)\n  }\n  setVariable(matlab_server,stretch=stretch)\n  cat(\"Generating egg mesh in Matlab\",sep=\"\\n\")\n  evaluate(matlab_server, paste(\"cd Code;Generate_Mesh_egg(stretch);\"))\n  close(matlab_server)\n  cat(\"Finished generating egg mesh in MATLAB\",sep=\"\\n\")\n  \n  Sphere_triang <- Load_egg_mesh()\n} else {\n  # mesh should not need updating for sphere as it does not change\n  Sphere_triang <- Load_sphere_mesh()\n}\np_lon_lat <- Convert_to_lon_lat(Sphere_triang@pars$p,1)\n# ------------------------------------------\n\n# READ OBSERVATIONS AND FIT SURFACE\n\nfor (j in 1:length(obs)) {\nprint(paste0(\"Fitting observations for \",obs[j]),quote=FALSE)\nflush.console()\n\n# READ OBSERVATIONS\nObs <- read.table(paste0(\"Observation_data/\",Obs_set,\"/\",obs[j],\".txt\"),header=T)\n#Convert to radians\nObs$x <- (Obs$x)*2*pi/360\nObs$y <- (Obs$y)*2*pi/360\n\n# Organise observations\nn_obs = nrow(Obs)      \nlocs = list(Obs$x,Obs$y)  \nlocs_xyz <- Convert_to_xyz(cbind(locs[[1]],locs[[2]]),r)\n\t\ny_obs <- data.frame(x=locs_xyz[,1], y = locs_xyz[,2], z = locs_xyz[,3], val = as.vector(Obs$z),lon=locs[[1]],lat=locs[[2]])\nQobs <- sparseMatrix(i=1:n_obs,j=1:n_obs,x=1/Obs$std^2)\n\n\n#-------------------\n# GP fit to the data: \ndesign.matrix <- y_obs[1:5,5:6] \ny.resp <- y_obs[1:5,4]\nmodel1 <- km( design=design.matrix, response=y.resp, covtype= \"matern5_2\") #no trend, nugget effect etc.\nmodel1 #see output of Kriging estimation\nmodel2 <- km( ~ lon + lat, design=design.matrix, response=y.resp, covtype= \"matern5_2\") #no trend, nugget effect etc.\nmodel2 #see output of Kriging estimation\n#The problem is that this returns a covariance matrix and we need to invert this to calculate the normal likelihood. \n#There are a number of approaches: composite likelihood, covariance tapering...\n\n#evaluate the likelihood of a draw from the GP using a covariance tapering approach.\n#we use the estimators found by the kriging method above.\nlogLik(model1)\n#calculate the likelihood by hand:\ntria_gp <- model1@T #upper triangular matrix from Cholesky decomposition of covariance matrix\n#covariance:\ncov_gp <- t(tria_gp)%*%tria_gp #have to use the matrix multiplication %*% not the element-wise *\nfit_gp <- model1@z\nloglik = -1/2*log(det(cov_gp)) - 1/2*(fit_gp%*%solve(cov_gp)%*%fit_gp)\n\n#1. Covariance Tapering:\n\n\n\n#2. Composite likelihood:\n\n\n} #/loop j\n\n\n# --------------------\n# Kriging on the sphere:\n\n##### EXAMPLE:\ndata(meuse)\ncoordinates(meuse) = ~x+y\ndata(meuse.grid)\ngridded(meuse.grid) = ~x+y\nm <- vgm(.59, \"Sph\", 874, .04)\n\n\n##### --------\n\n#Note that the geostatistical data is on the sphere and therefore we should be using kriging formula for spherical data. \n# This can be done using the gstat package.\n#we specify the exponential variogram model and calculate the empirical variogram as a function of lag:\n#empirical variogram:\n#The variogram uses euclidean coordiantes (this is fine due to the relationship between variogram in spherical and euclidean coordinates)\n#we maintain consistency of using r=1 (i.e. unit sphere)\nvgm.exp <- variogram(val ~ 1, ~ x + y + z, data = y_obs )  \n\n#Does this calculate point-pair distances and then bin them as in a histogram? And compute the gammma (variogram val)\n#for the bin value? This might make sense. It does! \n#line of best fit:\nmodel.fit <- vgm(\"Exp\") #if we enter no parameters then fit.variogram is called for the chosen model to estimate the parameters\nmodel.choice <- vgm(psill =  7, \"Exp\", range = 6.5, kappa = 0.05, nugget = 2) #chosen from plot of empirical variogram\nfit.vgm.exp <- fit.variogram(vgm.exp, model = model.choice)\n#Plotting the variogram for the data:\nplot(vgm.exp, model = fit.vgm.exp)\n\n\n#next the ordinary kriging model (constant mean) with exponential variogram model:\ndata <- y_obs[1:80,1:4]\nattach(data)\ncoordinates(data) = ~x+y+z\npred.grid <- y_obs[81:95,1:3]\n#data(pred.grid)\ncoordinates(pred.grid) = ~x+y+z\nm1.krig <- krige(val ~ 1, data, pred.grid, model = model.choice)\nm1.krig #the output are predictions at the locations specified.\n#this interpolates the value of the gaussian process at the specified locations. \nt(t(m1.krig$var1.pred - y_obs[81:95,4])) #compare to observations. Not good.\n\n###################\n# i) Simulated data exmaple: Lattice on R^2\n#1. Simulate the GP data:\nxy <- expand.grid(1:10, 1:10)\nnames(xy) <- c(\"x\",\"y\")\ngridded(xy) = ~x+y\nmodel.choice <- vgm(1,\"Exp\",15)\ng.dummy <- gstat(formula = z~1, dummy = TRUE, beta = 0,\n                 model = vgm(1,\"Exp\",15), nmax = 10) # for speed -- 10 is too small!!\nyy <- predict(g.dummy, xy, nsim = 1)\n# show one realisation:\nspplot(yy)\n\n#2. Fit GRF to recover semi-variogram\ndata1 <- cbind(yy@coords, yy@data$sim1)\ncolnames(data1) <- c(\"p\",\"q\",\"yy\") \ndata1 <- data.frame(data1) #needs to be a data frame\nattach(data1)\ncoordinates(data1) = ~ p + q\nvgm.exp <- variogram(yy ~ 1, data = data1)  \n#Does this calculate point-pair distances and then bin them as in a histogram? And compute the gammma (variogram val)\n#for the bin value? This might make sense. It does! \n#line of best fit:\nmodel.fit <- vgm(\"Exp\") #if we enter no parameters then fit.variogram is called for the chosen model to estimate the parameters\nmodel.bad.choice <- vgm(2, \"Sph\", 8, 0.1)\nmodel.bad.choice2 <- vgm(2, \"Gau\", 8, 0.1)\n\n#How good are the estimated parameters?\nfit.vgm.exp <- fit.variogram(vgm.exp, model = model.bad.choice2)\nfit.vgm.exp <- fit.variogram(vgm.exp, model = model.fit)\n\n#Plotting the variogram for the data:\nplot(vgm.exp, model = fit.vgm.exp)\n#The \"wrong\" choice of variogram fits the data as well as the data-generating choice. Perhaps the variograms are very similar.\n#This seems to be particularly true in the middle of the x-axis; there is a noticeable difference between Gau and Exp/Sph in the tails - as expected. \n\n#3. Prediction from the fitted model:\nkeep <- c(1,12,23,34,45,56,67,78,89,100)\ndata.pred <- data1[keep,]\ndata.pred.points <- data.frame(data.pred@coords)\ndata.fit <- data1[-keep,]\n#attach(data.fit)\n#coordinates(data.fit) = ~ p + q\nattach(data.pred.points)\ncoordinates(data.pred.points) = ~ p + q\nm1.krig <- krige(yy ~ 1, data.fit, data.pred.points, model = model.choice)\nm1.krig #the output are predictions at the locations specified.\n#this interpolates the value of the gaussian process at the specified locations. \nt(t(m1.krig$var1.pred - data.pred@data$yy)) #compare to observations.\n\n#4. Covariance matrix tapering:\n\n\n\n\n#######################################################\n## ii) Simulated Data Example: grid on R^3\n# 1. Simulate GF observations:\nxyz <- expand.grid(1:10, 1:10, 1:10)\nnames(xyz) <- c(\"x\",\"y\",\"z\")\ngridded(xyz) = ~x+y+z\nmodel.choice <- vgm(1,\"Exp\",15)\ng.dummy <- gstat(formula = val~1, dummy = TRUE, beta = 0,\n                 model = vgm(1,\"Exp\",15), nmax = 10) # for speed -- 10 is too small!!\nval <- predict(g.dummy, xyz, nsim = 1)\n\n#2. Fit GRF to recover semi-variogram\ndata2 <- cbind(val@coords, val@data$sim1)\ncolnames(data2) <- c(\"p\",\"q\",\"r\",\"val\") \ndata2 <- data.frame(data2) #needs to be a data frame\nattach(data2)\ncoordinates(data2) = ~ p + q + r\nvgm.exp <- variogram(val ~ 1, data = data2)  \n#Does this calculate point-pair distances and then bin them as in a histogram? And compute the gammma (variogram val)\n#for the bin value? This might make sense. It does! \n#line of best fit:\nmodel.fit <- vgm(\"Exp\") #if we enter no parameters then fit.variogram is called for the chosen model to estimate the parameters\nmodel.bad.choice <- vgm(2, \"Sph\", 8, 0.1)\nmodel.bad.choice2 <- vgm(2, \"Gau\", 8, 0.1)\n\n#How good are the estimated parameters?\nfit.vgm.exp <- fit.variogram(vgm.exp, model = model.choice)\nfit.vgm.exp <- fit.variogram(vgm.exp, model = model.bad.choice2)\nfit.vgm.exp <- fit.variogram(vgm.exp, model = model.fit)\n\n#Plotting the variogram for the data:\nplot(vgm.exp, model = fit.vgm.exp)\n#model fits the empirical variogram well again\n\n#3. Prediction from the fitted model:\nkeep <- c(1,12,23,34,45,56,67,78,89,100)\ndata.pred <- data2[keep,]\ndata.pred.points <- data.frame(data.pred@coords)\ndata.fit <- data2[-keep,]\n#attach(data.fit)\n#coordinates(data.fit) = ~ p + q\nattach(data.pred.points)\ncoordinates(data.pred.points) = ~ p + q + r\nm1.krig <- krige(val ~ 1, data.fit, data.pred.points, model = model.choice)\nm1.krig #the output are predictions at the locations specified.\n#this interpolates the value of the gaussian process at the specified locations. \nt(t(m1.krig$var1.pred - data.pred@data$yy)) #compare to observations.\n\n#4. Covariance matrix tapering:\n\n\n#######################################################\n## ii) Simulated Data Example: grid on S^2 (using (lon,lat) coords))\n#\n# prelim: testing code\n# 1. Testing is.projected in sp package - should be able to identify \n#\n# First, look at the meuse dataset:\ndata(meuse) #data.frame\ncoordinates(meuse) = ~x+y #SpatialPointsDataFrame \n#Meuse uses RDH coordinates (whatever these are)\nproj4string(meuse) <- CRS(\"+init=epsg:28992\") #is this the projection? See Rpubs Projection page. I think this is RDH projection.\nis.projected(meuse) #returns TRUE. We had to define the coordinate reference system.\nis.projected(meuse@proj4string)\n\n#smulating own dataset:\nlon_ <- seq(-20,20,length.out=11)\nlat_ <- seq(-50,50,length.out=11)\nsph.coord <- cbind(lon_,lat_)\nsph.coord <- data.frame(sph.coord)\nsph.coords <- SpatialPoints(sph.coord) #SpatialPoints because it does not contain values only locations?\n#sph.coord is in CRS (coordinate reference system) but arguments : NA (class: spatialPoints)\nproj4string(sph.coords) <- CRS(\"+init=epsg:4326\") #Mercerator projection code\nis.projected(sph.coords)\n#the output is True : What does this mean? And why do we find it? Should be FALSE. We don't want to use a projection. I don't understand.\n\n# 1. Simulate GF observations:\nxyz <- expand.grid(-10:10, -10:10, -10:10)\n#need to remove the (0,0,0) point because |.| is zero - should write code for this:\nxyz <- xyz[-4631,]\nnames(xyz) <- c(\"x\",\"y\",\"z\")\n#xyz_test <- xyz[1:10,]\n#convert this to the (lon,lat):\ntheta.phi <- Convert_to_lon_lat2(xyz) #assume the sphere has radius 1 (and the results is in radians)\n#I believe the code needs degrees (in proj4string inside sp package):\n#convert radians to degrees:\n#lon <- deg(theta.phi[,1]) \n#lat <- deg(theta.phi[,2]) \nlon.lat <- rad2deg(theta.phi) #code resticts to the range given below:\nlon.lat <- data.frame(lon.lat)\ncoordinates(lon.lat) <- c(\"lon\",\"lat\")\nproj4string(lon.lat) <- CRS(\"+init=epsg:4326\")\n#for proj4string we must have long in (-180,360) and lat in (-90,90)\nmodel.choice <- vgm(1,\"Exp\",15) #valid covariance function on the sphere\ng.dummy <- gstat(formula = val~1, dummy = TRUE, beta = 0,\n                 model = model.choice, nmax = 10) # for speed -- 10 is too small!!\n#The predict code uses is.projected to check for lon,lat coordinates (I think in degrees)\nval <- predict(g.dummy, lon.lat, nsim = 1)\n\n\n#2. Fit GRF to recover semi-variogram\ndata3 <- cbind(val@coords, val@data$sim1)\ncolnames(data3) <- c(\"p\",\"q\",\"val\") \ndata3 <- data.frame(data3) #needs to be a data frame\nattach(data3)\ncoordinates(data3) = ~ p + q \nvgm.exp <- variogram(val ~ 1, data = data3)  \n#Does this calculate point-pair distances and then bin them as in a histogram? And compute the gammma (variogram val)\n#for the bin value? This might make sense. It does! \n#line of best fit:\nmodel.fit <- vgm(\"Exp\") #if we enter no parameters then fit.variogram is called for the chosen model to estimate the parameters\n\n#How good are the estimated parameters?\nfit.vgm.exp <- fit.variogram(vgm.exp, model = model.choice)\n\n#Plotting the variogram for the data:\nplot(vgm.exp, model = fit.vgm.exp)\n#model fits the empirical variogram well again\n\n#3. Prediction from the fitted model:\nkeep <- c(1,120,2300,340,4500,560,670,7800,890,100)\n#keep <- c(9,10)\ndata.pred <- data3[keep,]\ndata.pred.points <- data.frame(data.pred@coords)\ndata.fit <- data3[-keep,]\n#attach(data.fit)\n#coordinates(data.fit) = ~ p + q\nattach(data.pred.points)\ncoordinates(data.pred.points) = ~ p + q \nm1.krig <- krige(val ~ 1, data.fit, data.pred.points, model = model.choice)\nm1.krig #the output are predictions at the locations specified.\n#This is indeed quite slow because we are inverting a large covariance matrix (10000 x 10000)\n#It also found covariance matrix to be singular so we cannot invert it. Why?\n#\n#this interpolates the value of the gaussian process at the specified locations. \nt(t(m1.krig$var1.pred - data.pred@data$val)) #compare to observations.\n\n#4. Covariance matrix tapering:\n\n\n#5. Composite Likelihood:\ncomp.data <- cbind(data.pred@coords,m1.krig$var1.pred) #coordinates and predictions for the likelihood calculation. \ncomp.negLogLik <- composite.nll(comp.data,c(5,5),\"Matern\",c(1,1,0.1))\n\n\n\n\n\n\n",
    "created" : 1486984294280.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3478663132",
    "id" : "A6643765",
    "lastKnownWriteTime" : 1488209642,
    "last_content_update" : 1488209642,
    "path" : "C:/Users/sm1pjp/Google Drive/Paelo Stuff/DMC/Scripts/Fit_eg_GP.R",
    "project_path" : "Fit_eg_GP.R",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}