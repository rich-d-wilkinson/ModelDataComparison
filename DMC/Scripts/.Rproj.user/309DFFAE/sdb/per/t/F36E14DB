{
    "collab_server" : "",
    "contents" : "## Taper function we're using\n\nwendland2.1 <- function(d, taprange){\n  d <- d/taprange\n  return((1-d)^4*(4*d+1)*(d<1))\n}\n\n## Get the storage information we'll need to create a sparse matrix\n\nmake.tapersetup <- function(d, f.tap, taprange)\n{\n  n <- nrow(d)\n  inrange <- d < taprange\n  good.dists <- d[inrange]\n  taps <- f.tap(good.dists, taprange)\n  names(taps) <- names(good.dists) <- NULL\n  ja <- row(d)[inrange]\n  ia <- as.integer(c(1, 1 + cumsum(apply(inrange, 1, sum))))\n  index <- (col(d)[inrange] - 1) * n + ja\n  return(list(n = n, good.dists = good.dists, taps = taps,\n              ja = ja, ia = ia, index = index))\n}\n\n## Likelihood functions -- these all have timing built into them\n## For general use, you may want to remove the timings\n\nnll <- function(x){\n  print(x)\n  times <- rep(NA, 5)\n  times[1] <- system.time(corr.matrix <- exp(-d/x))[1]\n  times[2] <- system.time(Q <- chol(corr.matrix))[1]\n  times[3] <- system.time(logdet <- 2 * sum(log(diag(Q))))[1]\n  times[4] <- system.time(bs <- backsolve(Q, z, transpose = TRUE))[1]\n  times[5] <- system.time(distval <- drop(crossprod(bs)))[1]\n  y <- (n * log(2 * pi) + n * log(distval / n) + logdet + n)/2\n  attr(y, \"times\") <- times\n  return(y)\n}\n\n## The next two functions require the spam package\n\nnll.1taper <- function(x, setup){\n  print(x)\n  times <- rep(NA, 5)\n  times[1] <- system.time(corr.matrix.Taper <- new(\"spam\",\n                                                   entries = exp(-setup$good.dists/x) *\n                                                   setup$taps,\n                                                   colindices = setup$ja,\n                                                   rowpointers = setup$ia,\n                                                   dimension = as.integer(rep(n, 2))))[1]\n  times[2] <- system.time(Q <- chol(corr.matrix.Taper))[1]\n  times[3] <- system.time(logdet <- 2 * as.numeric(determinant(Q, log = TRUE)$modulus))[1]\n  times[4] <- system.time(bs <- forwardsolve(Q, z))[1] # Same as usual backsolve(, transpose=TRUE)!\n  times[5] <- system.time(distval <- drop(crossprod(bs)))[1]\n  y <- (n * log(2 * pi) + n * log(distval / n) + logdet + n)/2\n  attr(y, \"times\") <- times\n  return(y)\n}\n\nnll.2taper <- function(x, setup){\n  print(x)\n  times <- rep(NA, 6)\n  times[1] <- system.time(corr.matrix.Taper <- new(\"spam\",\n                                                   entries = exp(-setup$good.dists/x) *\n                                                   setup$taps,\n                                                   colindices = setup$ja,\n                                                   rowpointers = setup$ia,\n                                                   dimension = as.integer(rep(n, 2))))[1]\n  times[2] <- system.time(Q <- chol(corr.matrix.Taper))[1]\n  times[3] <- system.time(logdet <- 2 * as.numeric(determinant(Q, log = TRUE)$modulus))[1]\n  times[4] <- system.time(inv <- backsolve(Q, forwardsolve(Q, diag(n))))[1]\n  times[5] <- system.time(slot(corr.matrix.Taper, \"entries\") <- inv[setup$index] *\n                          setup$taps)[1]\n  times[6] <- system.time(distval <- drop(t(z) %*% corr.matrix.Taper %*% z))[1]\n  y <- (n * log(2 * pi) + n * log(distval / n) + logdet + n)/2\n  attr(y, \"times\") <- times\n  return(y)\n}\n",
    "created" : 1487000602089.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2499744489",
    "id" : "F36E14DB",
    "lastKnownWriteTime" : 1486999756,
    "last_content_update" : 1486999756,
    "path" : "C:/Users/sm1pjp/Google Drive/Paelo Stuff/taperexample/functions.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}