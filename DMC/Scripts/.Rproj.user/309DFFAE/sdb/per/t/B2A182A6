{
    "collab_server" : "",
    "contents" : "#composite likelihood function:\n#Function to calculate the composite likelihood\n# Code Assumptions:\n# 1. Grid of coordinates is a square \n# 2.\n# Input:\n# data : this should contain the coordinates of the grid and the values at each node\n#       The grid of coordinates should be a square.\n# m : vector containing (m_x, m_y) - the number of blocks in the x and y direction respectively\n# Cov.fnc : Covariance matrix function. One of: Matern, ... .\n# Cov.par : parameters that define the covariance matrix function - the dimension will depend on cov.fnc\n# Output:\n#\n#\n\ncomposite.nll <- function(data, m, Cov.fnc, Cov.par){\n  n <- length(data[,1])\n  delta <- 0.1\n  p_begin.tilde <- min(data[,1],data[,2])\n  p_end.tilde <- max(data[,1],data[,2]) + delta #need to ensure that no block falls outside of the grid. \n  p_width <- p_end.tilde - p_begin.tilde\n  p_interval.x <- p_width/m[1]\n  p_interval.y <- p_width/m[2]\n  x_span <- seq(from = p_begin.tilde, to = p_end.tilde, by = p_interval.x)\n  y_span <- seq(from = p_begin.tilde, to = p_end.tilde, by = p_interval.y)\n  M <- m[1]*m[2]\n  #now we need to assign the locations to the relevant block. The blocks are across x and then up y etc.\n  x_span.loc <- array(0,dim=c(0))\n  y_span.loc <- array(0,dim=c(0))\n  for(i in 1:n){\n    x_span.loc <- cbind(x_span.loc,findInterval(data[i,1],x_span)) #find interval is left-closed and right open intervals\n    y_span.loc <- cbind(y_span.loc,findInterval(data[i,2],y_span))\n  }\n  D <- x_span.loc + m[1]*(y_span.loc - 1)    #identifying block that contains each observation.\n  #create blocks that contain the indices of the data in each block:\n  D_index <- append(0,which(D %in% 1))\n  for(i in 2:M){\n    D_index <- append(D_index,0)\n    D_index <- append(D_index,which(D %in% i))\n  }\n  D_index <- append(D_index,0) #needs zeros at the beginning and end\n  \n  #Note that the indices of a new block begins when the index is zero. \n  \n  D_Change <- blockChangeInd(D_index,M)\n  N_arrow <- neighbours.grid(m[1],m[2])$N_arrow #this tells us which D_Change to call.\n  #This code fails if any of the blocks are empty: So we create N_adj_arrow which removes all empty blocks\n  block_list <- seq(1,M,1) #all possible block numbers\n  remove_D <- block_list[!(block_list %in% D)] #identify blocks that do not appear in D - i.e. no observations lie within the block.\n  if( length(remove_D) > 0){\n    N_adj_arrow <- N_arrow[,!apply(N_arrow, 2, function(x) any(x %in% remove_D))]\n  }\n  else{\n    N_adj_arrow <- N_arrow\n  }\n  #Evaluate likelihood:\n  #browser()\n  nll.out <- 0\n  for(i in 1:dim(N_adj_arrow)[2]){ \n          nll.out <- nll.out + nll.calc(data, D_index[(D_Change[N_adj_arrow[1,i]]+1):(D_Change[N_adj_arrow[1,i]+1]-1)],\n                                    D_index[(D_Change[N_adj_arrow[2,i]]+1):(D_Change[N_adj_arrow[2,i]+1]-1)],Cov.par)\n  }\n return(nll.out)\n}\n\n#######################################################################\n# Auxillary functions:\n# 1. Matern covariance matrix function.\nmaternCov <- function(d,par.vec){\n  nu <- par.vec[1]\n  rho <- par.vec[2]\n  sigma <- par.vec[3]\n  out <- sigma^2*2^(1-nu)/gamma(nu)*(sqrt(2*nu)*d/rho)^nu*besselK(sqrt(2*nu)*d/rho,nu)\n  #if any element d=0 then we will get NA because of division by zero. We want to replace\n  #NA with sigma^2 (nugget effect)\n  out[out == \"NaN\"] <- sigma^2 #need more robust solution to this problem.\n  return(out)\n}\n\n# 2. Calculate covariance function for 2 given blocks:\nblockCovariance <- function(D1,D2,data,par.vec){\n  #distance calculation:\n  #1. sites for each block?\n  S1 <- data[D1,1:2] #coordinates of sites in block 1\n  S2 <- data[D2,1:2] \n  S_all <- rbind(S1,S2)\n  #2.distances of sites\n  dist.mat <- dist2(S_all,S_all,method=\"euclidean\")\n  #3.covariance matrix:\n  cov.mat <- maternCov(dist.mat,par.vec) #covariance matrix\n}\n\n# 3. Index where a new block starts:\nblockChangeInd <- function(D_index, M){\n  D_change <- array(0,dim=c(1,(M+1)))\n  k <- 1\n  for(i in 1:(M+1)){\n    while(D_index[k] > 0){\n      k <- k + 1\n    }\n    D_change[i] <- k\n    k <- k + 1\n  }\n  return(D_change)\n}\n\n# 4. calculate the negative log-likelihood\nnll.calc <- function(data, D1, D2, cov.par){\n  Cov <-  blockCovariance(D1,D2,data,cov.par)\n  #need to combine the covariance matrices together so that it is square ofc. \n  #then calculate the likelihood:\n  data_nll <- append(data[D1,3],data[D2,3])\n  out <- 1/2*log(det(Cov)) + 1/2*t(data_nll)%*%solve(Cov)%*%data_nll\n}\n\n#This code returns the pairs in N_k(arrow) from the composite likelihood paper.\nneighbours.grid <- function(Nx,Ny){ #Nx and Ny are the number of blocks in the x and y directions.  \n  ret<-c()\n  orig.mat <- matrix(1:(Nx*Ny),Nx,Ny)\n  temp.mat<-cbind(NA,rbind(NA,orig.mat,NA),NA)\n  addresses <- expand.grid(x = 1:Nx, y = 1:Ny)\n  for(i in 1:-1)\n    for(j in 1:-1)\n      if(i!=0 || j !=0)\n        ret<-rbind(ret,temp.mat[addresses$x+i+1+nrow(temp.mat)*(addresses$y+j)]) \n  \n  #ret is a matrix indicating which blocks are neighbours. Now we want to create N_k(arrow) \n  #We can do this by adding NA to the block pairs that are duplicates (i.e. j < i)\n  N_arrow <- array(0,c(2,0))\n  for(k in 1:(Nx*Ny)){\n    for(j in 1:8){\n      if(!is.na(ret[j,k]) && ret[j,k] > k)\n        N_arrow <- cbind(N_arrow, c(k,ret[j,k]))\n    }\n  }\n  \n list(ret=ret, N_arrow=N_arrow)\n}\n\n\n\nConvert_to_lon_lat2 <- function(X) {\n  r <- sqrt(X[,1]^2 + X[,2]^2 + X[,3]^2)\n  lat <- acos(X[,3]/r)\n  lon <- atan2(X[,2], X[,1])\n  return(cbind(lon,lat))\n}\n\nrad2deg <- function(X){ #we want to constrain angles to between certain values: can we do this without a loop?\n  new_X <- X*180/pi\n  n <- dim(new_X)[1]\n  for(i in 1:n){\n    if(new_X[i,1] < 0){\n      new_X[i,1] <- 360 + new_X[i,1] \n    }\n    \n    new_X[i,2] <- new_X[i,2] - 90 #we want (-90,90) for the paleo code.\n    \n  }\n  return(new_X)\n}\n\nConvert_to_xyz <- function(lonlat,r) {\n  x = r[1] * cos(lonlat[,2]) * cos(lonlat[,1])\n  y = r[2] * cos(lonlat[,2]) * sin(lonlat[,1])\n  z = r[3] *sin(lonlat[,2])\n  return(cbind(x,y,z))\n}\n\n",
    "created" : 1488447930434.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3458404367",
    "id" : "B2A182A6",
    "lastKnownWriteTime" : 1488364200,
    "last_content_update" : 1488364200,
    "path" : "C:/Users/sm1pjp/Google Drive/Paelo Stuff/DMC/Scripts/compNLL_Func.R",
    "project_path" : "compNLL_Func.R",
    "properties" : {
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}