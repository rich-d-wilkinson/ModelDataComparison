{
    "collab_server" : "",
    "contents" : "start_time <- proc.time()\nsource(\"Code/Init.R\")\nset.seed(1)\n\n# Example script\n\n# ------------------------------------------\n# INPUT DATA AND SETTINGS\n\n# Model settings\n# --------------\n# Models - gridded datasets of data values as a vector\n# Model outputs are stored in directory Model_Data/<Model_set> with filenames <models>.txt\n# Directory should also contain a file mask.txt with the indices of the region to be analysed\n# IDL file um2krig will prepare UM data appropriately\nModel_set='CO2_anom'\nmodels = c('tdgth', 'tczyi', 'tdgtj', 'tczyj', 'tdgtg', 'tczyk', 'tdgtk', 'tdgti')\n\n# Specify grid dimensions for model data\n# (lon_min,lon_max,lon_int,lat_min,lat_max,lat_int)\nmodel_grid <- c(-180,178.75,1.25,-89.375,89.375,1.25) # HadCM3 ocean temps, shifted 1 hemisphere\n# model_grid <- c(-180,176.25,3.75,-90,90,2.5)          # HadCM3 atmosphere temps, shifted 1 hemisphere\n# model_grid <- c(-179.5,179.5,1.0,89.5,-89.5,-1.0)     # HadISST data\n\n# Observations\n# -------------\n# Observations need to have points in a list of 4 columns with headers \"x,y,z,std\" = lon, lat, observation, uncertainty\n# Observations are stored in directory Observation_Data/<Obs_set> with filenames <obs>.txt\nObs_set='P3+_SST_anom'\nobs = c('lambda_100', 'lambda_90', 'lambda_80', 'lambda_70', 'lambda_60', 'lambda_50', 'lambda_40', 'lambda_30', 'lambda_20', 'lambda_10')\n\n# Mesh settings\n# -------------\n# Choose egg or sphere mesh\n#manifold = \"Egg\" \n manifold = \"Sphere\"\n\n# Matlab is called for egg meshes to generate new mesh with specified anisotropy = \"stretch\"  (MATLAB file: Generate_Mesh_egg.m)\n# stretch = sqrt of equatorial radius, default 0.05 (polar radius = 1)\n# Although stretch=1 should give a sphere, this doesn't actually seem to work for a reason I haven't worked out, use sphere option.\n#stretch <- 0.05 # Egg\n\n# Sphere - writes different set of mesh files (MATLAB file: Generate_Mesh.m)\n# For sphere option, don't need to vary radius, use smooth to vary region of influence, so this mesh is not updated.\nstretch <- 1 # Sphere\n\n# Calculation settings\n# -------------------\n# smoothness parameter, i.e. radius of influence. So higher is smoother. Default is smooth = 0.3.\nsmooth = 0.3\n\n# These lines retained for reference only - context within greater system.\nfit = \"Obs\" # \"Sim\" \"Obs\" or \"Model\"\n\n# Output\n# -------------------\nmesh <- paste0(manifold,\"-\",stretch)\noutdir <- paste0(\"Output/O-\",Obs_set,\"_M-\",Model_set,\"_ME-\",mesh,\"_SM-\",smooth)\n\n# ------------------------------------------\n# END - INPUT DATA AND SETTINGS\n# ------------------------------------------\n\n# INITIALISATION\n\nr = c(sqrt(stretch), sqrt(stretch),1) \nmodel_grid_rad <- model_grid*pi/180.\nLmodel_summary <- matrix(data=NA,nrow=length(obs),ncol=length(models))\n\n# SET UP GLOBAL MESH\n\n#Adjust radius in 3d space accordingly\nif (manifold == \"Egg\") {\n# Call Matlab to generate egg mesh with specified stretch value\nif (.Platform$OS.type == \"windows\"){\n    Matlab$startServer()\n    matlab_server <<- Matlab(remote=F)\n    Sys.sleep(10)\n    open(matlab_server)\n  } else if (.Platform$OS.type == \"unix\"){\n    Matlab$startServer()\n    matlab_server <<- Matlab(remote=F)\n    Sys.sleep(10)\n    open(matlab_server)\n  }\n  setVariable(matlab_server,stretch=stretch)\n  cat(\"Generating egg mesh in Matlab\",sep=\"\\n\")\n  evaluate(matlab_server, paste(\"cd Code;Generate_Mesh_egg(stretch);\"))\n  close(matlab_server)\n  cat(\"Finished generating egg mesh in MATLAB\",sep=\"\\n\")\n  \n  Sphere_triang <- Load_egg_mesh()\n} else {\n  # mesh should not need updating for sphere as it does not change\n  Sphere_triang <- Load_sphere_mesh()\n}\np_lon_lat <- Convert_to_lon_lat(Sphere_triang@pars$p,1)\n# ------------------------------------------\n\n# READ OBSERVATIONS AND FIT SURFACE\n\nfor (j in 1:length(obs)) {\nprint(paste0(\"Fitting observations for \",obs[j]),quote=FALSE)\nflush.console()\n\n# READ OBSERVATIONS\nObs <- read.table(paste0(\"Observation_data/\",Obs_set,\"/\",obs[j],\".txt\"),header=T)\n#Convert to radians\nObs$x <- (Obs$x)*2*pi/360\nObs$y <- (Obs$y)*2*pi/360\n\n# Organise observations\nn_obs = nrow(Obs)      \nlocs = list(Obs$x,Obs$y)  \nlocs_xyz <- Convert_to_xyz(cbind(locs[[1]],locs[[2]]),r)\n\t\ny_obs <- data.frame(x=locs_xyz[,1], y = locs_xyz[,2], z = locs_xyz[,3], val = as.vector(Obs$z),lon=locs[[1]],lat=locs[[2]])\nQobs <- sparseMatrix(i=1:n_obs,j=1:n_obs,x=1/Obs$std^2)\n\t\n# Find observation locations in mesh\nC_full <- FindC_sphere2(Sphere_triang@pars$p,Sphere_triang@pars$t,locs,r) \n## Phil: which of these are non-zero?\n# which( C_full[2,] > 0, arr.ind=TRUE)\n#I think C_full is the locations of the triangle that contains the observation, projected onto the plane tangential to sphere \n#at the observation. \n##\n# This is an updated, cool version of how we find points on the surface\n# I got around the problem by projecting twice, first using the real z-axis and then switching the z-axis with the y-axis and taking\n# the union of the two results. Works great.\n\n# GENERATE FIT SURFACE\n# Q is the precision matrix\nQ <- Prec_from_SPDE_wrapper(M = Sphere_triang@pars$M,\n                            K = Sphere_triang@pars$K,\n                            intrinsic = 0, \n                            nu = 1,\n                            desired_prec = 0.01*Imat(Sphere_triang@n),\n                            l = smooth)\n\t\t\t    \n# Structure\nInf_data <- list(C_full = C_full,\n                 Qobs = Qobs,\n                 y_obs = y_obs,\n                 Q = Q)\n\n# Now infer\nInf_data <- Infer(Inf_data)\n\n# Configure precision matrix\n# Simulate from using this precision matrix\nGMRF <- GMRF_init(as.matrix(rep(0,Sphere_triang@n)),Q,intrinsic = 0,perm=T,diag_offset=0.0001)\nx_sim <- SampleGMRF(GMRF,reps=1,use_perm=T)\n\n# EXTRACT RESULLTS\nRes <- Inf_data$Res\nRes <- cbind(Res,data.frame(x=p_lon_lat[,1],y=p_lon_lat[,2],val=x_sim))\n\n# ------------------------------------------\n# Read models and compare with observations\n\nfor (i in 1:length(models)) {\nprint(paste0(\"Reading model \",models[i]),quote=FALSE)\nflush.console()\n\n# Read_model_data generates the standard UM ocean grid and reads data into complete grid as vector\n# with NAs for land\nModel_df <- Read_model_data(modelpath = paste0(\"Model_data/\",Model_set,\"/\",models[i],\".txt\"),\n                            indexpath = paste0(\"Model_data/\",Model_set,\"/mask.txt\"),\n                            model_grid_rad, plot_it=T)\n# apply mask to results - this needs to be done once for each set of observations\nif (i == 1) {\n   # Apply mask to FE results: Res\n   # This could actually be done right at the top using p_lon_lat when the mesh is generated\n   # Mask would have to be read separatately.\n   # Slightly nervous that some processes seem to change the order of the data though.\n   print(\"Mapping mask locations onto FE mesh\",quote=FALSE)\n   mask <- data.frame(Model_df$x,Model_df$y,Model_df$mask)\n   names(mask) = c(\"grid_x\",\"grid_y\",\"mask\")\n   # Finds indices of Res (on FE grid) that are within mask (on model grid)\n   # Find model grid cell for each element of Res\n   Res$grid_x <- round((Res$x-model_grid_rad[1])/model_grid_rad[3])*model_grid_rad[3]+model_grid_rad[1]\n   Res$grid_y <- round((Res$y-model_grid_rad[4])/model_grid_rad[6])*model_grid_rad[6]+model_grid_rad[4]\n   # Round x and y values to pre-empt merge failures\n   # This method might be flaky, time will tell! Merge needs exact values to work.\n   Res$grid_x  <- round(Res$grid_x,digits=4)\n   Res$grid_y  <- round(Res$grid_y,digits=4)\n   mask$grid_x <- round(mask$grid_x,digits=4)\n   mask$grid_y <- round(mask$grid_y,digits=4)\n   # Lookup mask values for Res\n   Res <- merge(Res,mask,by=c(\"grid_x\",\"grid_y\"),all.x=T,sort=F)\n   mask_ind <- which(Res$mask == 1)\n   # Locate any points that have failed and print out\n   mask_fail_ind <- which(is.na(Res$mask))\n   if (length(mask_fail_ind) != 0) {\n      mask_fail <- cbind(Res$grid_x[mask_fail_ind]*180/pi,Res$grid_y[mask_fail_ind]*180/pi)\n      print(\"Mask location failures\",quote=FALSE)\n      print(mask_fail)\n      # don't get rid of the failures, just set the NAs to 0 so they will be ignored\n      Res$mask[mask_fail_ind] <- 0\n      }\n} # end mask\n\n# This function removes all the NAs from the vector\nModel_df <- Model_df[complete.cases(Model_df),]\n\n# Add the models I want to compare to the results by regressing onto the sphere. Here I just add Model_df\nRes <- Add_model(Res,Model_df,Sphere_triang,name=\"Model\",r) \n\n# ------------------------------------------\n\n# CALCULATE LOG LIKELIHOOD BOTH INCLUDING AND EXCLUDING MASK AREAS\n\n# This won't work because the zero at land really gives the field a low probability (not smooth at all)\n\nLmodel <- logLik_prop(Res$Model,Res$mean,Inf_data$Qtot)\n\nQpost_mask <- chol2inv(chol(chol2inv(chol(Inf_data$Qtot))[mask_ind,mask_ind]))\nLmodel_mask <- logLik_prop(Res$Model[mask_ind],\n                              Res$mean[mask_ind],\n                              Qpost_mask)\n\nLmodel_summary[j,i] <- Lmodel_mask\n\nNull_Lmodel_mask <- logLik_prop(0*Res$Model[mask_ind],\n                              Res$mean[mask_ind],\n                                   Qpost_mask)\n} # model loop/ i\n\n# ------------------------------------------\n\n# OUTPUT\nprint(\"Generating output\",quote=FALSE)\n\n# FE output for each set of observations\n\n# This writes the FE output surface for the mask region only to file - this is probably not much use to most end users\nif (!(file.exists(outdir))) {\n   dir.create(outdir)\n   }\n# write.table(Res[mask_ind,],file = paste0(\"outdir,\"/\",obs[j],\"_FE-output.txt\"))\n\n# Grid data for plotting/output for each set of observations\n\ndetail=200 # number of points in each grid direction\nGG <- Triang_to_grid(Res,\"mean\",detail)\nGGstd <- Triang_to_grid(Res,\"std\",detail)\nGGmask <- Triang_to_grid(Res,\"mask\",detail)\nGGtrue <- Triang_to_grid(Res,\"val\",detail)\nGGcv <- GG; GGcv$z <- GG$z/GGstd$z\nGmodel <- Triang_to_grid(Res,\"Model\",detail)\n\n# Create data frame with gridded results and remove NaNs\nRes_grid <- data.frame(GG,GGstd,GGmask)\nRes_grid <- Res_grid[complete.cases(Res_grid),]\n\n# This writes the rectangular gridded output of mean, std and mask to file for plotting\nwrite.table(Res_grid,file = paste0(outdir,\"/\",obs[j],\"_grid_output.txt\"))\n} # fit loop/ j\n\n# Results matrix\nResults <- as.data.frame(Lmodel_summary)\ncolnames(Results) <- models\nrownames(Results) <- obs\n\nprint(\"Results matrix\",quote=FALSE)\nprint(Results)\nflush.console()\n\nwrite.table(Results,file = paste0(outdir,\"/Results_matrix.txt\"))\nend_time <- proc.time()\nprint(\"Total time\",quote=FALSE)\nprint(end_time - start_time)\n\n\n",
    "created" : 1486133075457.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1688954909",
    "id" : "28E1AC66",
    "lastKnownWriteTime" : 1486480559,
    "last_content_update" : 1486480559020,
    "path" : "C:/Users/Phillip/Google Drive/Paelo Stuff/DMC/Scripts/Fit_eg_annotate.R",
    "project_path" : "Fit_eg_annotate.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}