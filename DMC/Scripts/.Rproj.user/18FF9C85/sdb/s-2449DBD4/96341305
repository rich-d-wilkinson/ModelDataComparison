{
    "collab_server" : "",
    "contents" : "Prec_from_lattice <- function(Grid,ds)\n{\n  n <- nrow(Grid)\n  #### set up distance and neighbourhood (W, based on sharing a common border) matrices\n  distance <-array(0, c(n,n))\n  W <- as.matrix(dist(Grid))==ds\n  n.neighbours <- as.numeric(apply(W, 1, sum))\n  Q <- diag(n.neighbours) - W\n  return(as(Q,\"dgCMatrix\"))\n}\n\n# interpolates a continuous data set onto a grid\nnn_grid_interp <- function(s,df,delta=10,miss_value=NA) {\n  if (length(delta) == 1) {\n    s_rnd <- data.frame(round(s/delta)*delta)\n  } else {\n    s_rnd <- data.frame(round(s[,1]/delta[1])*delta[1],round(s[,2]/delta[2])*delta[2])\n  }\n  s_rnd[,3] <- 1:nrow(s_rnd)\n  names(s_rnd) = c(\"x\",\"y\",\"n\")    \n  df_sub <- subset(df,(x >= min(s_rnd$x) &\n                         x <= max(s_rnd$x) &\n                         y >= min(s_rnd$y) &\n                         y <= max(s_rnd$y))) \n  df <- merge(df_sub,s_rnd,all.y=T)               \n  df <- arrange(df,n)\n  if (any(is.na(df$z)))  df[is.na(df$z),]$z <- miss_value\n  return(df$z)\n}\n\ncholPermute <- function(Q)  {\n  n <- dim(Q)[1]\n  \n  e <-tryCatch({ symchol <- Cholesky(Q)},error= function(temp) {print(\"Cholesky failed, coercing to symmetric\")},finally=\"Cholesky successful\")\n  if (class(e) == \"character\")  {\n    symchol <- Cholesky(forceSymmetric(Q))\n  }\n  \n  \n  j <- 1:n\n  i <- symchol@perm + 1\n  P <- sparseMatrix(i,j,x=rep(1,n))\n  if (class(e) == \"character\")  {\n    Qpermchol <- t(chol(forceSymmetric(t(P)%*%Q%*%P)))\n  } else { Qpermchol <- t(chol(t(P)%*%Q%*%P)) }\n  return(list(Qpermchol=Qpermchol,P=P))\n}\n\n\n\n\n## Solve Qx = y\ncholsolve <- function(Q,y,perm=F,cholQ = matrix(1,0,0),cholQp = matrix(1,0,0),P=NA)  {\n  if (perm == F) {\n    if (dim(cholQ)[1] == 0) {\n      e <-tryCatch({L <- t(chol(Q))},error= function(temp) {print(\"Cholesky failed, coercing to symmetric\")},finally=\"Cholesky successful\")\n      if (class(e) == \"character\") {\n        L <- t(chol(forceSymmetric(Q))) }\n    }  else {\n      L <- cholQ\n    }\n    \n    v <- solve(L,y)\n    x <- solve(t(L),v)\n  }\n  if (perm == T) {\n    if (dim(cholQp)[1] == 0) {\n      QP <- cholPermute(Q)\n      Lp <- QP$Qpermchol\n      P <- QP$P\n    } else {\n      Lp <- cholQp\n    }\n    \n    v <- solve(Lp,t(P)%*%y)\n    w <- solve(t(Lp),v)\n    x <- P%*%w\n  }\n  return(x)\n}\n\n\n\n\n\nTakahashi_Davis <- function(Q,return_perm_chol = 0,cholQp = matrix(0,0,0),P=0) {\n  \n  n <- dim(Q)[1]\n  \n  if (dim(cholQp)[1] == 0) {\n    symchol <- Cholesky(forceSymmetric(Q))\n    j <- 1:n\n    i <- symchol@perm + 1\n    P <- sparseMatrix(i,j,x=rep(1,n))\n    Lperm <- L <- t(chol(t(P)%*%Q%*%P))\n  } else {\n    Lperm <- L <- cholQp\n    P <- P\n  }\n  \n  d = diag (L)\n  Ld <- L%*%sparseMatrix(i=1:n,j=1:n,x=1/d)\n  L <- tril(Ld,-1)\n  U = t(L)\n  d = d^2\n  D = sparseMatrix(i=1:n,j=1:n,x=d)\n  \n  R = as(L+D,\"dgTMatrix\")\n  R = sparseMatrix(i=R@i+1,j=R@j+1,x=1) ;\n  Zpattern = R + t(R) - sparseMatrix(i=1:n,j=1:n,x=1)\n  \n  Z <- sparseinv_wrapper(L,d,t(U),Zpattern)\n  if (return_perm_chol == 0) {\n    return(P%*%Z%*%t(P))\n  } else {\n    return(list(S=P%*%Z%*%t(P),Lp = Lperm,P=P))\n  }\n  \n}\n\nsparseinv_wrapper <- function(L,d,U,Zpattern) {\n  \n  n <- dim(L)[1]\n  Lp <- L@p\n  Li <- L@i\n  Lx <- L@x\n  \n  Up <- U@p\n  Uj <- U@i\n  Ux <- U@x\n  \n  Zpatp <- Zpattern@p\n  Zpati <- Zpattern@i\n  znz = Zpatp [n+1]\n  \n  if (.Platform$OS.type == \"windows\") {\n    dyn.load(\"./Code/sparseinv/R_WINDOWS/sparseinvR.dll\")\n  } else {\n    dyn.load(\"./Code/sparseinv/R_UNIX/sparseinvR.so\")\n  }\n  X <- .C(\"sparseinv\",as.integer(n),as.integer(Lp),as.integer(Li),as.double(Lx),as.double(d),as.integer(Up),as.integer(Uj),as.double(Ux),as.integer(Zpatp),as.integer(Zpati),result = double(znz))\n  \n  Lower <- L + sparseMatrix(i=1:n,j=1:n,x = d)\n  Zp <- Lower@p\n  Zi <- Lower@i\n  Zx <- X$result[-which(X$result == 0)]\n  Z <- sparseMatrix(p = Zpatp, i =Zpati, x = X$result,index1=F)\n  return(Z)\n}\n\nlogLik_prop <- function(x,mu,Q) {\n  return( 0.5*logdet(chol(Q)) - as.vector(0.5*t(x - mu) %*% Q %*% (x - mu) ))\n}\n\nCARfit <- function(x,y,yobs) {\n  ds1 <- mean(diff(x))\n  ds2 <- mean(diff(y))\n  if(ds1 !=  ds2) {\n    y  = y*ds1/ds2\n    yobs$y  = yobs$y*ds1/ds2\n  }\n  ds <- ds1\n  Grid <- as.data.frame(expand.grid(x, y))\n  Q <- Prec_from_lattice(Grid,ds)\n  n <- nrow(Grid)\n  names(Grid) <- c(\"x\",\"y\")\n  Grid$z <- 1:nrow(Grid)\n  m <- nrow(yobs)\n  Qobs <- sparseMatrix(i=1:m,j=1:m,x=1/(yobs$std^2))\n  Ci <- 1:nrow(yobs)\n  Cj <- nn_grid_interp(yobs,Grid,delta=ds)\n  C <- sparseMatrix(i = Ci, j = Cj, x=1,,dims=c(m,n))  \n  \n  ybar = t(C)%*%Qobs%*%(yobs$z) \n  Qtot <- t(C)%*%Qobs%*%C + Q \n  X <- cholPermute(Qtot)\n  Partial_Cov <- Takahashi_Davis(Qtot,cholQp = X$Qpermchol,P = X$P)\n  Grid$std <- as.vector(sqrt(diag(Partial_Cov)))\n  Grid$mean <- as.vector(cholsolve(Qtot,ybar,perm=T,cholQp = X$Qpermchol, P = X$P))\n  Grid$y <- Grid$y * ds2/ds1\n  return(list(data=Grid,Q = Qtot))\n}\n\nInfer <- function(Inf_mats) {\n  C_full = Inf_mats$C_full\n  y_obs = Inf_mats$y_obs\n  Qobs = Inf_mats$Qobs\n  Q = Inf_mats$Q\n  \n  ybar = t(C_full)%*%Qobs%*%matrix(y_obs$val) \n  Qtot <- t(C_full)%*%Qobs%*%C_full + Q \n  X <- cholPermute(Qtot)\n  Partial_Cov <- Takahashi_Davis(Qtot,cholQp = X$Qpermchol,P = X$P)\n  Resstd <- as.vector(sqrt(diag(Partial_Cov)))\n  Resmean <- as.vector(cholsolve(Qtot,ybar,perm=T,cholQp = X$Qpermchol, P = X$P))\n  Res = list(mean = Resmean, std=Resstd)\n  Inf_mats$Qtot = Qtot\n  Inf_mats$Res = Res\n  return(c(Inf_mats))\n}\n\n\n# Multiple plot function\n#\n# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)\n# - cols:   Number of columns in layout\n# - layout: A matrix specifying the layout. If present, 'cols' is ignored.\n#\n# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),\n# then plot 1 will go in the upper left, 2 will go in the upper right, and\n# 3 will go all the way across the bottom.\n#\nmultiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {\n  require(grid)\n  \n  # Make a list from the ... arguments and plotlist\n  plots <- c(list(...), plotlist)\n  \n  numPlots = length(plots)\n  \n  # If layout is NULL, then use 'cols' to determine layout\n  if (is.null(layout)) {\n    # Make the panel\n    # ncol: Number of columns of plots\n    # nrow: Number of rows needed, calculated from # of cols\n    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),\n                     ncol = cols, nrow = ceiling(numPlots/cols))\n  }\n  \n  if (numPlots==1) {\n    print(plots[[1]])\n    \n  } else {\n    # Set up the page\n    grid.newpage()\n    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))\n    \n    # Make each plot, in the correct location\n    for (i in 1:numPlots) {\n      # Get the i,j matrix positions of the regions that contain this subplot\n      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n      \n      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                      layout.pos.col = matchidx$col))\n    }\n  }\n}\n\nmarg_prec_from_kappa <- function(kappa_l,nu) {\n  return(1/(gamma(nu)/(gamma(nu+1)*4*pi*kappa_l^(2*nu))))\n}\n\n\nPrec_from_SPDE <- function(M,K,tau,kappa,alpha=1)  {\n  if (!(alpha %in% c(1,2,3,4))) {\n    stop(\"alpha > 4 not implemented yet\")\n  }\n  n <- nrow(M)\n  if(class(tau) == \"numeric\") {\n    tau <- sparseMatrix(i=1:n,j=1:n,x=tau)\n  }\n  if(class(kappa) == \"numeric\") {\n    kappa <- sparseMatrix(i=1:n,j=1:n,x=kappa)\n  }\n  \n  M_approx <- sparseMatrix(i=1:n,j=1:n,x=rowSums(M))\n  M_approx_inv <- sparseMatrix(i=1:n,j=1:n,x=1/rowSums(M))\n  M_kappa2 <- kappa%*%M%*%kappa\n  G <- (M_kappa2 + K)\n  if (alpha == 1) {\n    Q <- tau%*%G%*%tau\n  } else if (alpha ==2) {\n    Q <- tau%*%G%*%M_approx_inv%*%G%*%tau\n  } else if (alpha == 3) {\n    Q <-  tau%*%G%*%M_approx_inv%*%G%*%M_approx_inv%*%G%*%tau\n  } else if (alpha == 4) {\n    Q <-  tau%*%G%*%M_approx_inv%*%G%*%M_approx_inv%*%G%*%M_approx_inv%*%G%*%tau\n  }\n  return(Q)\n}\n\nPrec_from_SPDE_wrapper <- function(M,K,intrinsic,nu,desired_prec,l) {\n  kappa_l = sqrt(8*nu)/l\n  marg_prec <- marg_prec_from_kappa(kappa_l,nu)\n  tau <- sqrt(desired_prec/marg_prec)\n  Q <- Prec_from_SPDE(M,K,tau=tau,kappa=kappa_l,alpha=nu+1)\n}\n\n\nGMRF_init <- function(mu = 0, Q = 1, intrinsic = 0,perm=T,diag_offset=0.00000000001, Chol=0) {\n  n = length(mu)\n  if (intrinsic == 0)   {\n    Quncon <- Q\n    this_class <- 'GMRF'\n  }\n  # Create a new IGMRF of first order\n  if (intrinsic == 1)    {           # See Rue & Held pg. 108\n    #Quncon <- (Q + 1*matrix(1,n,n))\n    Quncon <- Q + diag_offset*sparseMatrix((1:n),(1:n),x=1)\n    this_class <- 'IGMRF1'\n  }\n  \n  if (intrinsic == 2) {\n    A = matrix(1,2,n)\n    A[2,] <- 1:n\n    #Quncon <- (Q + t(A)%*%A)\n    Quncon <- Q + diag_offset*sparseMatrix((1:n),(1:n),x=1)\n    this_class <- 'IGMRF2'\n  }\n  \n  if(!is.list(Chol)) {\n    cholQ <- t(chol(Quncon))\n    \n    if (perm == T) {\n      # Find permutation matrices\n      # The default used is AMD\n      # See http://www.cise.ufl.edu/research/sparse/cholmod/CHOLMOD/Doc/UserGuide.pdf\n      QP <- cholPermute(Quncon)\n      obj <- list(mu = mu,Q = Q,cholQ = cholQ,cholQ.perm = QP$Qpermchol,P = QP$P,Quncon = Quncon)\n      # Here fill-in is defined as the ratio of non-zeros in L to the non-zeros in the lower triangular part of Q\n      #cat(paste(\"Fill-in before permutation=\" ,length(which(t(cholQ)!=0))/length(which(tril(Q)!=0))),sep=\"\\n\")\n      #cat(paste(\"Fill-in after permutation (AMD)=\" ,length(which(t(QP$Qpermchol)!=0))/length(which(tril(Q)!=0))),sep=\"\\n\")\n    }\n    \n    else {\n      obj <- list(mu = mu,Q = Q,cholQ = cholQ,Quncon = Quncon)\n    }\n  } else {\n    obj <- list(mu = mu,Q = Q,cholQ.perm = Chol$Qpermchol,P = Chol$P)\n  }\n  class(obj) <- this_class\n  return(obj)\n}\n\n\n## Sample from the GMRF (both intrinsic and non-intrinsic)\nSampleGMRF <- function(G,reps=1,use_perm=F) {\n  n = length(G$mu)\n  x <- matrix(0,n,reps)\n  z <- matrix(rnorm(n*reps),n,reps)\n  \n  # Algorithm 2.4, Rue and Held\n  if (use_perm ==F) {\n    for (i in (1:reps)) {\n      v <- solve(t(G$cholQ),z[,i])\n      x[,i] <- matrix(G$mu + v)\n    }\n  }\n  \n  if (use_perm == T) {\n    for (i in (1:reps)) {\n      #zbar <- t(G$P)%*%G$cholQ%*%z[,i]\n      #v1 <- solve(G$cholQ.perm,zbar)\n      #v2 <- solve(t(G$cholQ.perm),v1)\n      #x[,i] <- matrix(G$mu + G$P%*%v2)\n      \n      v <- G$P %*% solve(t(G$cholQ.perm), z[,i])\n      x[,i] <- matrix(G$mu + v)\n      \n    }\n  }\n  \n  if(class(G) == \"IGMRF1\")  {    # Algorithm 2.6, Rue and Held - correct\n    A = matrix(1,1,n)\n    P1 <- solve(G$cholQ,t(A))\n    V <- solve(t(G$cholQ),P1)\n    W <- A%*%V\n    cholW = chol(W)\n    P2 <- solve(cholW,t(V))\n    U  <- solve(t(cholW),P2)\n    for (i in (1:reps)) {\n      cvec <- A %*% x[,i]                                                     \n      x[,i] <- x[,i] - matrix(t(U) %*% cvec)\n    }\n  }\n  \n  if(class(G) == \"IGMRF2\")  {    # Algorithm 2.6, Rue and Held - correct\n    A = matrix(1,2,n)\n    A[2,] <- 1:n\n    P1 <- solve(G$cholQ,t(A))\n    V <- solve(t(G$cholQ),P1)\n    W <- A%*%V\n    U  <- solve(W,t(V))\n    for (i in (1:reps)) {\n      cvec <- A %*% x[,i]\n      x[,i] <- x[,i] - matrix(t(U) %*% cvec)\n    }\n  }\n  \n  \n  return(x)\n  \n}\n\n\nConvert_to_lon_lat <- function(X,r) {\n  lat <- asin(X[,3]/r)\n  lon <- atan2(X[,2], X[,1])\n  return(cbind(lon,lat))\n}\n\nConvert_to_xyz <- function(lonlat,r) {\n  x = r[1] * cos(lonlat[,2]) * cos(lonlat[,1])\n  y = r[2] * cos(lonlat[,2]) * sin(lonlat[,1])\n  z = r[3] *sin(lonlat[,2])\n  return(cbind(x,y,z))\n}\n\n\n## Find C matrix when observations are isolated points\nFindC_sphere <- function(p,tri,locs,r) {\n  if (length(locs[[1]]) > 0)  {\n    # See http://stackoverflow.com/questions/1185408/converting-from-longitude-latitude-to-cartesian-coordinates     \n    \n    protate <- function(p,angle) {\n      p <- p + angle\n      p[p < -pi] = p[p < -pi] + 2*pi\n      p[p > pi] = p[p  > pi] - 2*pi\n      return(p)\n    }\n    \n    \n    p_lon_lat <- Convert_to_lon_lat(p,r[3])\n    locs_xyz <- Convert_to_xyz(cbind(locs[[1]],locs[[2]]),r)\n    cat(\"Observations close to East-West boundary will cause error\",sep=\"\\n\")\n    \n    \n    \n    \n    # OK so the way to sort this is to do the below both like this and for z-axis interchanged\n    # with x-axis or y-axis. This will work if we only do the latitudes < 80 for both axes.\n    \n    # We need to do some geomatric acrobatics to find which triangle the output is at lon boundaries\n    remove_tri <- NULL\n    count =0\n    for (i in 1:nrow(tri)) {\n      this_p <- p_lon_lat[tri[i,],]\n      if (diff(range(this_p[,1])) > r[1]) remove_tri <- c(remove_tri,i)\n\n    }\n    tri_temp <- tri[-remove_tri,]\n    t_num <- tsearch(p_lon_lat[,1], p_lon_lat[,2], tri_temp, locs[[1]], locs[[2]], bary = FALSE) # Find triangles in lat/lon\n    for (i in 1:length(t_num)) {\n       t_num[i] <- (1:nrow(tri))[-remove_tri][t_num[i]] # Correct indices for what we removed\n    }\n    \n    # Now repeat the same exercise with everything rotated by 90 degrees\n    remove_tri <- NULL\n    for (i in 1:nrow(tri)) {\n      this_p <- p_lon_lat[tri[i,],]\n      this_p[,1] <- protate(this_p[,1],pi/2)\n      if (diff(range(this_p[,1])) > r[1]) remove_tri <- c(remove_tri,i)\n    }\n    tri_temp2 <- tri[-remove_tri,]\n    t_num2 <- tsearch(protate(p_lon_lat[,1],pi/2), p_lon_lat[,2], tri_temp2, protate(locs[[1]],pi/2), locs[[2]], bary = FALSE) # Find triangles in lat/lon\n    for (i in 1:length(t_num2)) {\n      t_num2[i] <- (1:nrow(tri))[-remove_tri][t_num2[i]] # Correct indices for what we removed\n    }\n    t_num[is.na(t_num)] = t_num2[is.na(t_num)]\n\n#     # Version 2\n#     for (i in 1:length(locs[[1]])) {\n#       this_obs <- c(locs[[1]][i],locs[[2]][i])\n#       this_p <- cbind(p_lon_lat[,1] - this_obs[1],p_lon_lat[,2] - this_obs[2])\n#       this_p[this_p[,1] < -pi,1] = this_p[this_p[,1] < -pi,1] + 2*pi\n#       this_p[this_p[,1] > pi,1] = this_p[this_p[,1]  > pi,1] - 2*pi\n#       this_p[this_p[,2] < -pi/2,2] = this_p[this_p[,2] < -pi/2,2] + pi\n#       this_p[this_p[,2] > pi/2,2] = this_p[this_p[,2]  > pi/2,2] - pi\n#       this_p_xyz <- Convert_to_xyz(this_p,r)\n#       this_p2 <- Convert_to_lon_lat(this_p_xyz,r[3])\n#     }\n#     \n#     \n#     # Version 2\n#     t_num_new<- rep(0,length(locs[[1]]))\n#     for (i in 1:length(locs[[1]])) {\n#       this_obs <- c(locs[[1]][i],locs[[2]][i])\n#       #Perform an albers projection centred at this coordinate\n#       p_proj <- mapproject(p_lon_lat[,1],p_lon_lat[,2],projection=\"trapezoidal\",par=c(locs[[1]][i],locs[[2]][i]))\n#       obs_proj <- mapproject(locs[[1]][i],locs[[2]][i],projection=\"trapezoidal\",par=c(locs[[1]][i],locs[[2]][i]))\n#       p_proj <- mapproject(p_lon_lat[,1],p_lon_lat[,2],projection=\"rectangular\",par=c(locs[[2]][i]))\n#       obs_proj <- mapproject(locs[[1]][i],locs[[2]][i],projection=\"rectangular\",par=c(locs[[2]][i]))\n#       t_num_new[i] <- tsearch(p_proj$x,p_proj$y, tri, obs_proj$x,obs_proj$y, bary = FALSE) # Find triangles in lat/lon\n#     }\n#     tri_df <- as.data.frame(tri)\n#     t_num <- rep(0,length(locs[[1]]))\n#     # Use 3D information\n#     for (i in 1:length(locs[[1]])) {\n#       dist <- data.frame(dist = sqrt((p[,1] - locs_xyz[i,1])^2 + (p[,2] - locs_xyz[i,2])^2 + (p[,3] - locs_xyz[i,3])^2),\n#                          n = 1:nrow(p))\n#       c = sort(dist)[1,2]\n#       tris <- subset(tri_df, (V1 == c[1] | V2 == c[1] | V3 == c[1])) # These are the possible triangles holding the points. Now search\n#       in_tri <- rep(0,6)\n#       for(j in 1:nrow(tris)) {\n#         \n#         # Project triangle onto a plane\n#         this_p <- p[as.numeric(tris[j,]),]\n#         d1 = sqrt((this_p[1,1] - this_p[1,2])^2 + (this_p[2,1] - this_p[2,2])^2  + (this_p[3,1] - this_p[3,2])^2)\n#         d2 = sqrt((this_p[1,1] - this_p[1,3])^2 + (this_p[2,1] - this_p[2,3])^2  + (this_p[3,1] - this_p[3,3])^2)\n#         d3 = sqrt((this_p[1,2] - this_p[1,3])^2 + (this_p[2,2] - this_p[2,3])^2  + (this_p[3,2] - this_p[3,3])^2)\n#         p_proj <- matrix(0,3,2)\n#         p_proj[2,] = c(d1,0);\n#         xx = (d2^2 - d3^2 + d1^2)/(2*d1);\n#         p_proj[3,] = c(xx,sqrt(d2^2 - xx^2));\n#         \n#         # Project obs onto the plane\n#         this_obs <- Convert_to_xyz(cbind(locs[[1]][i],locs[[2]][i]),r)\n#         T <- rbind(t(p_proj),c(0,0,0)) %*% solve(t(this_p)) # transofmration matrix\n#         obs_proj <- (T %*% t(this_obs))[1:2,]\n#         \n#         in_tri[j] <- pnt.in.poly(t(matrix(obs_proj)),p_proj)$pip\n#       }\n#       t_num[i] <- as.numeric(row.names(tris))[which(in_tri == 1)[1]]\n#     }\n#     \n    \n  # GOOD BUT STILL HAVE MULTIPLE NAs at the top edges for some reason\n    \n   z <- j_ind <- i_ind <- matrix(0,length(t_num),3)\n    b <- matrix(0,3,1)\n    A <- matrix(0,3,3)\n    A[,1] = 1\n    \n    for (i in 1:length(t_num)) {\n      t_num_i <- t_num[i]\n      this_tri <- tri[t_num_i,]\n      this_p <- p[this_tri,]\n      \n      # Correct for longitude boundary\n      if (diff(range(this_p[,1])) > r[1]) {\n        this_p[,1] <- protate(this_p[,1],pi/2)\n      }\n      \n      # Project triangle onto a plane\n      d1 = sqrt((this_p[1,1] - this_p[1,2])^2 + (this_p[2,1] - this_p[2,2])^2  + (this_p[3,1] - this_p[3,2])^2)\n      d2 = sqrt((this_p[1,1] - this_p[1,3])^2 + (this_p[2,1] - this_p[2,3])^2  + (this_p[3,1] - this_p[3,3])^2)\n      d3 = sqrt((this_p[1,2] - this_p[1,3])^2 + (this_p[2,2] - this_p[2,3])^2  + (this_p[3,2] - this_p[3,3])^2)\n      p_proj <- matrix(0,3,2)\n      p_proj[2,] = c(d1,0);\n      xx = (d2^2 - d3^2 + d1^2)/(2*d1);\n      p_proj[3,] = c(xx,sqrt(d2^2 - xx^2));\n      \n      A[,2:3] <- p_proj\n      Ainv <- solve(A) \n      \n      \n      # Project obs onto the plane\n      this_obs <- Convert_to_xyz(cbind(locs[[1]][i],locs[[2]][i]),r)\n      T <- rbind(t(p_proj),c(0,0,0)) %*% solve(t(this_p)) # transofmration matrix\n      obs_proj <- (T %*% t(this_obs))[1:2,]\n      \n      for (j in 1:3) {\n        b[,] <- 0\n        b[j] <- 1\n        i_ind[i,j] <- i\n        j_ind[i,j] <- this_tri[j]\n        z[i,j] <- matrix(c(1,obs_proj[1],obs_proj[2]),1,3)%*%Ainv%*%b\n      }\n    }\n    \n    C <- sparseMatrix(as.vector(i_ind),as.vector(j_ind),x=as.vector(z),\n                      dims = c(length(locs[[1]]),dim(p)[1]))\n    return(C)\n  }  else {\n    return(matrix(1,0,0))\n  }\n  \n}\n\n\n## Find C matrix when observations are isolated points\nFindC_sphere2 <- function(p,tri,locs,r) {\n  if (length(locs[[1]]) > 0)  {\n    # See http://stackoverflow.com/questions/1185408/converting-from-longitude-latitude-to-cartesian-coordinates     \n    \n    protate <- function(p,angle) {\n      p <- p + angle\n      p[p < -pi] = p[p < -pi] + 2*pi\n      p[p > pi] = p[p  > pi] - 2*pi\n      return(p)\n    }\n    locs_xyz <- Convert_to_xyz(cbind(locs[[1]],locs[[2]]),r)\n    t_num <- matrix(length(locs[[1]]),2)\n    \n    t_try <- matrix(0,length(locs[[1]]),2)\n    for(j in 1:2) {\n      if (j == 1) {\n        p_lon_lat <- Convert_to_lon_lat(p,r[3])\n        locs_vec <-  Convert_to_lon_lat(locs_xyz,r[3])\n      } else {\n        p_lon_lat <- Convert_to_lon_lat(cbind(p[,1],p[,3],p[,2]),r[3])\n        locs_vec <-  Convert_to_lon_lat(cbind(locs_xyz[,1],locs_xyz[,3],locs_xyz[,2]),r[3])\n      }\n      locs[[1]] <- locs_vec[,1]\n      locs[[2]] <- locs_vec[,2]\n      \n        # OK so the way to sort this is to do the below both like this and for z-axis interchanged\n        # with x-axis or y-axis. This will work if we only do the latitudes < 80 for both axes.\n        \n        # We need to do some geomatric acrobatics to find which triangle the output is at lon boundaries\n        remove_tri <- NULL\n        count =0\n        for (i in 1:nrow(tri)) { # Find which triangles to remove\n\t      # print(paste0(\"FindC_sphere2: \",i),quote=FALSE)\n\t      # flush.console()\n          this_p <- p_lon_lat[tri[i,],]\n          if (diff(range(this_p[,1])) > r[1]) remove_tri <- c(remove_tri,i)\n        }\n        tri_temp <- tri[-remove_tri,]\n        t_num <- tsearch(p_lon_lat[,1], p_lon_lat[,2], tri_temp, locs[[1]], locs[[2]], bary = FALSE) # Find triangles in lat/lon\n        for (i in 1:length(t_num)) {\n          t_num[i] <- (1:nrow(tri))[-remove_tri][t_num[i]] # Correct indices for what we removed\n        }\n        \n        # Now repeat the same exercise with everything rotated by 90 degrees\n        remove_tri <- NULL\n        for (i in 1:nrow(tri)) {\n            # print(paste0(\"FindC_sphere2 - 90: \",i),quote=FALSE)\n            # flush.console()\n         this_p <- p_lon_lat[tri[i,],]\n          this_p[,1] <- protate(this_p[,1],pi/2)\n          if (diff(range(this_p[,1])) > r[1]) remove_tri <- c(remove_tri,i)\n        }\n        tri_temp2 <- tri[-remove_tri,]\n        t_num2 <- tsearch(protate(p_lon_lat[,1],pi/2), p_lon_lat[,2], tri_temp2, protate(locs[[1]],pi/2), locs[[2]], bary = FALSE) # Find triangles in lat/lon\n        for (i in 1:length(t_num2)) {\n          t_num2[i] <- (1:nrow(tri))[-remove_tri][t_num2[i]] # Correct indices for what we removed\n        }\n        t_num[is.na(t_num)] = t_num2[is.na(t_num)]\n        t_try[,j] <- t_num\n    \n    }\n    \n    # There are very minor differences between the two due to the project but we don't care about points which are largely on the boundary so we take \n    # the first column and only those of the second which are NA in the first\n    which_na <- is.na(t_try[,1])\n    t_try[which_na,1] <- t_try[which_na,2]\n    t_num <- t_try[,1]\n    # GOOD BUT STILL HAVE MULTIPLE NAs at the top edges for some reason\n    \n    z <- j_ind <- i_ind <- matrix(0,length(t_num),3)\n    b <- matrix(0,3,1)\n    A <- matrix(0,3,3)\n    A[,1] = 1\n    \n    # Convert back to default\n    p_lon_lat <- Convert_to_lon_lat(p,r[3])\n    locs_vec <-  Convert_to_lon_lat(locs_xyz,r[3])\n    locs[[1]] <- locs_vec[,1]\n    locs[[2]] <- locs_vec[,2]\n    \n    for (i in 1:length(t_num)) {\n      t_num_i <- t_num[i]\n      this_tri <- tri[t_num_i,]\n      this_p <- p[this_tri,]\n      \n      # Correct for longitude boundary\n         print(paste0(\"FindC_sphere - lon bound: \",i),quote=FALSE)\n         flush.console()\n      if (diff(range(this_p[,1])) > r[1]) {\n        this_p[,1] <- protate(this_p[,1],pi/2)\n      }\n      \n      # Project triangle onto a plane\n      d1 = sqrt((this_p[1,1] - this_p[1,2])^2 + (this_p[2,1] - this_p[2,2])^2  + (this_p[3,1] - this_p[3,2])^2)\n      d2 = sqrt((this_p[1,1] - this_p[1,3])^2 + (this_p[2,1] - this_p[2,3])^2  + (this_p[3,1] - this_p[3,3])^2)\n      d3 = sqrt((this_p[1,2] - this_p[1,3])^2 + (this_p[2,2] - this_p[2,3])^2  + (this_p[3,2] - this_p[3,3])^2)\n      p_proj <- matrix(0,3,2)\n      p_proj[2,] = c(d1,0);\n      xx = (d2^2 - d3^2 + d1^2)/(2*d1);\n      p_proj[3,] = c(xx,sqrt(d2^2 - xx^2));\n      \n      A[,2:3] <- p_proj\n      Ainv <- solve(A) \n      \n      \n      # Project obs onto the plane\n      this_obs <- Convert_to_xyz(cbind(locs[[1]][i],locs[[2]][i]),r)\n      T <- rbind(t(p_proj),c(0,0,0)) %*% solve(t(this_p)) # transformation matrix\n      obs_proj <- (T %*% t(this_obs))[1:2,]\n      \n      for (j in 1:3) {\n        b[,] <- 0\n        b[j] <- 1\n        i_ind[i,j] <- i\n        j_ind[i,j] <- this_tri[j]\n        z[i,j] <- matrix(c(1,obs_proj[1],obs_proj[2]),1,3)%*%Ainv%*%b\n      }\n    }\n    \n    C <- sparseMatrix(as.vector(i_ind),as.vector(j_ind),x=as.vector(z),\n                      dims = c(length(locs[[1]]),dim(p)[1]))\n    return(C)\n  }  else {\n    return(matrix(1,0,0))\n  }\n  \n}\n\n\nOverlayPlot <- function(GG,GGstd=NULL,leg_title=\"\",do_mesh=1,zlo = -0.6,zhi = 0.6,alphalo = 0.2, alphahi = 1) {\n  GG$zlo = zlo\n  GG$zhi = zhi\n  if ((sign(zhi) - sign(zlo)) == 2) {\n    g <- LinePlotTheme() + geom_tile(data=GG,aes(x=x,y=y,fill=pmin(pmax(z,zlo),zhi))) +\n      scale_fill_gradient2(low=(muted(\"blue\")),mid=\"light yellow\",high=(muted(\"red\")),\n                           guide=guide_colourbar(title=leg_title),limits=c(zlo,zhi)) \n  } else {\n    g <- LinePlotTheme() + geom_tile(data=GG,aes(x=x,y=y,fill=pmin(pmax(z,zlo),zhi))) +\n      scale_fill_gradient(low=\"light yellow\",high=(muted(\"green\")),\n                           guide=guide_colourbar(title=leg_title),limits=c(zlo,zhi)) \n  }\n    \n  \n  if (!is.null(GGstd)){\n    GGstd$alphalo = alphalo\n    GGstd$alphahi = alphahi\n    g <- g+ geom_tile(data=GGstd,aes(x=x,y=y, alpha=-pmax(pmin(z,alphahi),alphalo)),fill=\"white\")\n    \n  }\n  #   g <- g + theme(panel.background = element_rect(fill='white', colour='white'),panel.grid=element_blank(),panel.grid.major=element_blank(), panel.grid.minor=element_blank(),\n  #          axis.ticks=element_blank(),axis.text.x=element_blank(),axis.text.y=element_blank()) +\n  g <- g + coord_fixed(ratio=1) + xlab(\"\") + ylab(\"\")\n  g <- g + theme(legend.position=\"right\") + scale_alpha(guide = 'none')\n  \n  # theme(legend.key.width=unit(4,\"lines\")) + theme(legend.key.height=unit(4,\"lines\")) +\n  # theme(text = element_text(size=40))\n  return(g)\n}\n\nOverlay_data <- function(g,Obs) {\n  g <- g + geom_point(data=Obs,aes(x,y),size=5,colour=\"black\") + \n    geom_point(data=Obs,aes(x,y,colour=pmin(pmax(z,-10),10)),size=4) + \n    scale_colour_gradient2(low=muted(\"blue\"),mid=\"light yellow\",high=muted(\"red\"),limits=c(-10,10))\n}\nAdd_coast <- function(g,coastline) {\n  g <- g + geom_polygon(data=coastline,aes(x,y,group=id))\n}\n\nTriang_to_grid <- function(df,name,detail,wrap=T) {\n  \n  if(wrap){\n   leftoverlap = subset(df, x < (-pi + pi))\n   leftoverlap$x = leftoverlap$x + 2*pi\n   rightoverlap = subset(df, x > pi - pi)\n   rightoverlap$x = rightoverlap$x - 2*pi\n   \n   df <- rbind(df,leftoverlap,rightoverlap)\n   \n   detail = detail*2\n  }\n  \n  G <- interp(df$x,df$y,df[name][,1],xo=seq(min(df$x),max(df$x),length=detail),yo=seq(min(df$y),max(df$y),length=detail))\n  GG <- cbind(expand.grid(G$x,G$y),as.vector(G$z))\n  names(GG) <- c(\"x\",\"y\",\"z\")\n  if(wrap) {\n   GG <- subset(GG,x > -pi & x < pi) \n  }\n  return(GG)\n}\n\nLandAttribute <- function(df,coastline) {\n  df$in_land =0\n  for( i in unique(coastline$id)) {\n    my_sub <- subset(coastline,id==i)\n    myind <- which(pnt.in.poly(cbind(df$x,df$y),my_sub[c(\"x\",\"y\")])$pip == 1)\n    df$in_land[myind] <- i\n  }\n  return(df)\n}\n\nAdd_model <- function(Res,Model_df,Sphere_triang,name,r=1) {\n  Model3d <- as.data.frame(cbind(Convert_to_xyz(cbind(Model_df$x,Model_df$y),r),val=Model_df$z))\n  Res[name]=0\n  for (i in 1:nrow(Model3d)) {\n    p <- Sphere_triang@pars$p\n    dist <- sqrt((p[,1] - Model3d$x[i])^2 + (p[,2] - Model3d$y[i])^2 + (p[,3] - Model3d$z[i])^2)\n    Res$Model[which.min(dist)] = Model3d$val[i]\n  }\n  return(Res)\n}\n\nRead_model_data <- function(modelpath,indexpath,model_grid,plot_it=T) {\n  Model_data <- cbind(read.table(modelpath,col.names=\"z\"),\n                      read.table(indexpath,col.names=\"n\"))\n  \n  grid_x <- seq(model_grid[1],model_grid[2],model_grid[3])\n  grid_y <- seq(model_grid[4],model_grid[5],model_grid[6])\n  grid <- data.frame(expand.grid(grid_x,grid_y))\n  names(grid) = c(\"x\",\"y\")\n  grid$n <- 1:nrow(grid)\n  grid$mask <- rep(0,nrow(grid))\n  mask_id <- Model_data$n\n  grid$mask[mask_id] <- 1\n  Model_df <- merge(grid,Model_data,by=\"n\",all.x=T)\n  if (plot_it){\n     g <- LinePlotTheme() + geom_tile(data=Model_df,aes(x,y,fill=pmin(pmax(z,-5),5))) + \n       scale_fill_gradient2(low=muted(\"blue\"),mid=\"light yellow\",high=muted(\"red\"),limits=c(-5,5)) + coord_fixed()\n     print(g)\n  }\n      \n  #Convert to radians\n  #Model_df$x <- (Model_df$x)*2*pi/360\n  #Model_df$y <- (Model_df$y)*2*pi/360\n  \n  return(Model_df)\n}\n\n\nLoad_sphere_mesh <- function() {\n  \n  p  <- (as.matrix(read.table('./Code/p.csv',sep=\",\")))\n  tri <- as.matrix(read.table('./Code/tri.csv',sep=\",\"))\n  M <-  as.matrix(read.table('./Code/Sphere1_M.csv',sep=\",\"))\n  K <-  as.matrix(read.table('./Code/Sphere1_K.csv',sep=\",\"))\n  n <- nrow(p)\n  M <- sparseMatrix(i=M[,1],j=M[,2],x=M[,3],dims=c(n,n))\n  K <- sparseMatrix(i=K[,1],j=K[,2],x=K[,3],dims=c(n,n))\n  \n  Mesh <- initFEbasis(p=p, t = tri, M = M, K = K)\n  \n  return(Mesh)\n  \n}\n\nLoad_egg_mesh <- function() {\n  \n  p  <- (as.matrix(read.table('./Code/p_egg.csv',sep=\",\")))\n  tri <- as.matrix(read.table('./Code/tri_egg.csv',sep=\",\"))\n  M <-  as.matrix(read.table('./Code/Egg_M.csv',sep=\",\"))\n  K <-  as.matrix(read.table('./Code/Egg_K.csv',sep=\",\"))\n  n <- nrow(p)\n  M <- sparseMatrix(i=M[,1],j=M[,2],x=M[,3],dims=c(n,n))\n  K <- sparseMatrix(i=K[,1],j=K[,2],x=K[,3],dims=c(n,n))\n  \n  Mesh <- initFEbasis(p=p, t = tri, M = M, K = K)\n  \n  return(Mesh)\n  \n}\n\nRead_coastline <- function() {\n  \n  coastline <- readShapeSpatial(\"./Code/shapefiles/ne_110m_land.shp\")\n  coastline_fort <- fortify(coastline)\n  coastline_fort$x <- coastline_fort$long*2*pi/360\n  coastline_fort$y <- coastline_fort$lat*2*pi/360\n  return(coastline_fort)\n  \n}\n\n\n\n",
    "created" : 1486138463095.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4169328276",
    "id" : "96341305",
    "lastKnownWriteTime" : 1486119814,
    "last_content_update" : 1486119814,
    "path" : "C:/Users/Phillip/Google Drive/Paelo Stuff/DMC/Scripts/Code/Paleo_Functions.R",
    "project_path" : "Code/Paleo_Functions.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}