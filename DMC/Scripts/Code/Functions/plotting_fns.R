## Draw a graph of the precision matrix
DrawGraph <- function(Q,fixed=NA)   {
          diag(Q) <- 0
          Q[which(Q!=0)] = 1 		# make symbolic
          mygraph <- graph.adjacency(Q,mode="undirected")
          if(is.na(fixed)){
            layout =  layout.fruchterman.reingold(mygraph)
          } else {W
            layout =  fixed
          }
          
          
          if (dim(Q)[1] < 200) {
          plot(mygraph,layout=layout,vertex.size=4,vertex.label.dist=0.5,vertex.color="red",edge.arrow.size=0.5)
          } else {
          plot(mygraph,layout=layout,vertex.size=4,vertex.label.dist=NA,vertex.color="red",edge.arrow.size=0.5)
          }
}

circleFun <- function(center = c(0,0),diameter = 1, npoints = 100){
  r = diameter / 2
  tt <- seq(0,2*pi,length.out = npoints)
  xx <- center[1] + r * cos(tt)
  yy <- center[2] + r * sin(tt)
  return(data.frame(x = xx, y = yy))
}


plot_scale_bar <- function(g_orig,x=0,y=0,l=10)  {
  df1 <- data.frame(x = c(x, x = x + l/2,  x = x + l/2,  x = x), 
                   y = c(y + l/20,y + l/20, y - l/20, y - l/20))
  df2 <- data.frame(x = c(x, x = x - l/2,  x = x - l/2,  x = x), 
                    y = c(y + l/20,y + l/20, y - l/20, y - l/20))
  dftext <- data.frame(x = x, y = y - l/3, l= l)
  g <- g_orig + geom_polygon(data=df1,aes(x,y),colour="black",fill="white") +
                geom_polygon(data=df2,aes(x,y),colour="black",fill="black") + 
                geom_text(data=dftext,aes(x,y,label = paste(l,'km')))
  return(g)
  
}

ggplotGraph <- function(Q,fixed=NA,point_size=0.5,g = NULL,plot_dots=T) {
  
  library(network)
  library(sna)
  library(ergm)
  
  net <- network(Q,directed = F,density=0.3)
  m <- as.matrix.network.adjacency(net) # get sociomatrix
  plotcord <- data.frame(X1=fixed[,1],X2=fixed[,2])
  edglist <- as.matrix.network.edgelist(net)
  edges <- data.frame(plotcord[edglist[,1],], plotcord[edglist[,2],])
  colnames(edges) <-  c("X1","Y1","X2","Y2")
  edges$midX  <- (edges$X1 + edges$X2) / 2
  edges$midY  <- (edges$Y1 + edges$Y2) / 2
  if (class(g)[1] == "NULL") {
      pnet <- ggplot()  +
        geom_segment(aes(x=X1, y=Y1, xend = X2, yend = Y2),
                     data=edges, size = 0.3, colour="grey") +
        scale_colour_brewer(palette="Set1") +
        scale_x_continuous(breaks = NULL) + scale_y_continuous(breaks = NULL) +
        # discard default grid + titles in ggplot2
        theme(panel.background = element_blank()) + theme(legend.position="none")+
        theme(axis.title.x = element_blank(), axis.title.y = element_blank()) +
        theme( legend.background = element_rect(colour = NA)) +
        theme(panel.background = element_rect(fill = "white", colour = NA)) +
        theme(panel.grid.minor = element_blank(), panel.grid.major = element_blank()) 
       } else {
         pnet <- g  +
           geom_segment(aes(x=X1, y=Y1, xend = X2, yend = Y2),
                        data=edges, size = 0.3, colour="grey") +
           scale_colour_brewer(palette="Set1") +
           scale_x_continuous(breaks = NULL) + scale_y_continuous(breaks = NULL) +
           # discard default grid + titles in ggplot2
           theme(panel.background = element_blank(), legend.position="none",
                legend.background = element_rect(colour = NA), panel.background = element_rect(fill = "white", colour = NA),
                panel.grid.minor = element_blank(), panel.grid.major = element_blank()) 
       }
  if(plot_dots) pnet <- pnet + geom_point(aes(X1, X2),colour="red", data=plotcord,size=point_size)
  return(pnet)
  
}

## Plot a spatial field from vertices
PlotSpatField <- function(p,x,my_title = '',ylab="",zlim=c(0,0),palette=brewer.pal(11,"RdBu"),res=200)  {
 surf <- akima::interp(x=p[,1],y=p[,2],z=x,xo=seq(min(p[,1]), max(p[,1]), length = res),yo=seq(min(p[,2]), max(p[,2]), length = res))
 if ((zlim[1] == 0) && (zlim[2] == 0)) zlim <- range(surf$z,na.rm=T)
 zlen <- zlim[2] - zlim[1]

 surf$z[which(surf$z < zlim[1])] = zlim[1]
 surf$z[which(surf$z > zlim[2])] = zlim[2]


  image(x=surf$x, y=surf$y, z=surf$z,col=palette, axes=F, zlim=zlim, xlab="", ylab=ylab)
 image.plot( zlim=zlim, col=palette, legend.only=TRUE, horizontal =TRUE)
 grid()
 box()
# filled.contour(surf$x, surf$y, surf$z,color.palette=terrain.colors,xlab='x',ylab='y')
 title(my_title)
 return(surf)
}

## Plot from Voronoi tesselations
DrawfromVoronoi <- function(Voronoi,col,p) {
      n = length(col)
      for (i in 1:n)  {
          edges <- rbind(as.matrix(subset(Voronoi$dirsgs,ind1 ==i,select=c(x1,y1,bp1))),
                   as.matrix(subset(Voronoi$dirsgs,ind2 ==i,select=c(x1,y1,bp1))),
                   as.matrix(subset(Voronoi$dirsgs,ind1 ==i,select=c(x2,y2,bp2))),
                   as.matrix(subset(Voronoi$dirsgs,ind2 ==i,select=c(x2,y2,bp2))))
          X <- unique(edges)
          if(sum(X[,3])>0) {
            X <- rbind(X,c(p[i,],0))
          }
          edges <- X[,(1:2)]
          edges <- edges[chull(edges), ]
          polygon(unname(edges[,1]),unname(edges[,2]),col=col[i],border='NA')
      }
    }


LinePlotTheme <- function() {
  g <- ggplot() + theme(panel.background = element_rect(fill='white', colour='black'),text = element_text(size=20),
              panel.grid.major =  element_line(colour = "light gray", size = 0.05),
              panel.border  = element_rect(fill=NA, colour='black') ) 
   return (g)
}


EmptyTheme <- function() {
  g <- ggplot() +  theme(panel.background = element_rect(fill='white', colour='white'),panel.grid=element_blank(),axis.ticks=element_blank(),
                panel.grid.major=element_blank(),panel.grid.minor=element_blank(),axis.text.x=element_blank(),axis.text.y=element_blank())
  return (g)
}


## this temperature field suggested in Kaye et al (2011), Fig 3 in the
## response to my comment
makeKaye1 <- function(mbr = c(-15, 0, 10, 25), sdbr = c(0.3, 0.6, 1),rtb=F) {

  stopifnot(length(mbr) == 4, length(sdbr) == 3)

  if (rtb == F) {
  sat <- cbind(red = c(0, 100, 240, 230, 170),
               green = c(0, 180, 210, 120, 0),
               blue = c(170, 255, 0, 0, 0))
  } else {
    sat <- cbind(red = c(170,230,240,100,0),
               green = c(0,120,210,180,0),
               blue = c(0,0,0,255,170))
  }


  pp <- c(0, 0.33, 0.66, 1)
  coltab <- sapply(pp, function(x) {
    y <- (1 - x) * sat + x * 255
    rgb(y[, "red"], y[, "green"], y[, "blue"], alpha = 255, maxColorValue = 255)
  })

  rownames(coltab) <- c(paste("<", mbr[1]),
                        paste(mbr[-length(mbr)], mbr[-1], sep = " to "),
                        paste(">=", mbr[length(mbr)]))
  mbr <- c(-Inf, mbr, Inf) # for cut

  sdbr <- c(0, sdbr)
  colnames(coltab) <- c(paste(sdbr[-length(sdbr)], sdbr[-1], sep = " to "),
                        paste(">=", sdbr[length(sdbr)]))
  sdbr <- c(sdbr, Inf) # for cut

  function(m, sd = 0) {
    m <- cut(m, breaks = mbr, right = FALSE, labels = FALSE) # in 1:5 (small - large)
    sd <- cut(sd, breaks = sdbr, right = FALSE, labels = FALSE)  # in 1:4 (unc - certain)
    coltab[cbind(m, sd)]
  }
}



mymap <- function(grid, col, Dx,
                  xlim = c(-180, 180), ylim = c(-85, 85),
                  add = FALSE,
                  coast = c("under", "over", "none"), colcoast = "darkgrey",
                  boxtype = c("ticks", "none", "box")) {

  ## simple checks

  stopifnot(is.data.frame(grid), c("lon", "lat") %in% names(grid),
            nrow(grid) == length(col))
  coast <- match.arg(coast)
  boxtype <- match.arg(boxtype)

  ## fill in gridcell widths

  if (missing(Dx)) {
    Dx <- sapply(grid[, c("lon", "lat")], function(x)
                 min(diff(unique(sort(x)))))
#     cat(sprintf("** \'Dx\' inferred from grid, dlon = %.2f, dlat = %.2f\n",
#                 Dx["lon"], Dx["lat"]))
  }

  ## initialise plot and plot gridcells

  #if (!add)
  #  map(xlim = xlim, ylim = ylim, type = "n", mar = par("mar"))
  #if (coast == "under")
  #  map(interior = FALSE, add = TRUE, col = colcoast, mar = par("mar"))

  rect(grid$lon, grid$lat, grid$lon + Dx["lon"], grid$lat + Dx["lat"],
    col = col, border = col, lwd = 0, ljoin = 1)

  #if (coast == "over")
  #  map(interior = FALSE, add = TRUE, col = colcoast, mar = par("mar"))

  if (boxtype == "box") box()
  else if (boxtype == "ticks") {
    axis(1, at = pretty(xlim, 10), tcl = 0.25, cex.axis = 0.7,
      mgp = c(2, 0.0, 0))
    axis(2, at = pretty(ylim, 7), tcl = 0.25, cex.axis = 0.7,
      mgp = c(2, 0.25, 0), las = 1)
    box()
  }

  invisible(NULL)
}


 DrawKaylePalette <- function(coltab)
 {
    ## create legend as separate figure
    do.call(getOption("device"), list(width = 4, height = 3.5))
    coltab <- get("coltab", envir = environment(Kaye))
    par(mar = c(4, 5.5, 1, 1), mgp = c(1.25, 0.25, 0), las = 1, cex = 0.8)

    plot.new()
    plot.window(xlim = c(0, 4), ylim = c(0, 5))

    xleft <- rep(0:3, 5); ybottom = rep(0:4, rep(4, 5))
    rect(xleft, ybottom, xleft + 1, ybottom + 1, col = t(coltab), border = "darkgrey")
    axis(1, at = 0:3 + 0.5, colnames(coltab), tick = FALSE)
    #title(xlab = "Standard deviation (m/a)", line = 2)
    axis(2, at = 0:4 + 0.5, rownames(coltab), tick = FALSE)
    #title(ylab = "Height change (m/a)", line = 3.75)

 }

## Draw a border using countours from a mask of 1/0s
DrawBorderFromMask <- function(x,y,z)    {
  contour(unique(x),unique(y),z,axis=T,levels=seq(from=-3, to=3, by=1),drawlabels = F,add=T,lwd=1)
}

## Plot gridded data from N x 1 vectors
Plot_gridded_data <- function(x,y,z,palette=rainbow(128),zlim=c(-1,1),xlab="",ylab="")    {
  x <- unique(x)
  y <- unique(y)
  z <- reshape(matrix(z),length(y),length(x))
  image(x=x, y=y, z=t(z),col=palette, axes=F, zlim=zlim, xlab=xlab, ylab=ylab)
  image.plot( zlim=zlim, col=palette, legend.only=TRUE, horizontal =TRUE)
  grid()
  box()
}

Plotsigmafromkappa <- function(sigma,a,b) {
       plot(sigma,2*sigma^(-3)*dgamma(1/(sigma^2),shape=a,rate=b),ylab="")  
} 


# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  require(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}



error.bar <- function(x, y, upper, lower=upper, length=0.1,...){
    if(length(x) != length(y) | length(y) !=length(lower) | length(lower) != length(upper))
    stop("vectors must be same length")
    arrows(x,y+upper, x, y-lower, angle=90, code=3, length=length, ...)
    }



get_ellipse <- function(data, fill){
  edata <- as.matrix(data)
  ehull <- ellipsoidhull(edata)
  phull <- as.data.frame(predict(ehull))
  data.frame(
    x=phull$V1, 
    y=phull$y, 
    fill=rep(fill, nrow(phull))
  )
}

PlotAntarctica <- function(g,shapefiles) {
  g <- g +
    geom_path(data = shapefiles$grounding_sub,aes(long,lat),colour="black") +
    geom_path(data= shapefiles$coast_sub,aes(long,lat),linetype=2,size=0.5) +
    geom_path(data=shapefiles$Islands,aes(x,y,group=id))  + xlab("x (km)") + ylab("y (km)")
  return(g)
}
